# 排课系统设计报告

## 目录

<!-- TOC -->

- [排课系统设计报告](#排课系统设计报告)
    - [目录](#目录)
    - [文档修改历史](#文档修改历史)
    - [设计背景](#设计背景)
    - [技术栈](#技术栈)
    - [主要](#主要)
        - [前端](#前端)
        - [后端](#后端)
    - [技术栈介绍](#技术栈介绍)
        - [vue](#vue)
        - [vue-router](#vue-router)
        - [element-ui](#element-ui)
        - [axios](#axios)
        - [Springboot](#springboot)
        - [MongoDB](#mongodb)
    - [使用这套技术栈的原因](#使用这套技术栈的原因)
    - [开发工具](#开发工具)
    - [开发流程](#开发流程)
        - [模块设计](#模块设计)
        - [体系结构设计](#体系结构设计)
        - [功能设计](#功能设计)
            - [Course模块](#course模块)
            - [Classroom模块](#classroom模块)
            - [Teacher模块](#teacher模块)
            - [Scheduling模块(核心功能、没有实现)](#scheduling模块核心功能没有实现)
    - [核心算法设计](#核心算法设计)
        - [假设](#假设)
        - [数据说明](#数据说明)
            - [时间的表示](#时间的表示)
        - [外部输入参数](#外部输入参数)
        - [数据库设计](#数据库设计)
            - [Course文档](#course文档)
            - [Classroom文档](#classroom文档)
            - [Teacher文档](#teacher文档)
            - [Scheduling文档](#scheduling文档)
        - [算法实现](#算法实现)
            - [检测当前教室是否可以被占用](#检测当前教室是否可以被占用)

<!-- /TOC -->

## 文档修改历史

| 修改日期  |               修改原因               | 版本号 |
| :-------: | :----------------------------------: | :----: |
| 2019.7.24 | 完成报告的初版，达到与代码设计的同步 |  v1.0  |

## 设计背景

1. 自学web项目开发所做的一个项目
2. 管理信息系统作业

## 技术栈

## 主要

- vue + Springboot + MongoDB

### 前端

- vue
- vue-router
- element-ui
- axios

### 后端

- Springboot
- MongoDB

## 技术栈介绍

### vue

- 一种网页的开发框架
- 使用组件化开发的理念，将每个页面当做组件，每个页面中还可以放入小的组件，这样可以减少重复代码

### vue-router

- 网页开发的路由管理器，具体就是将**每个组件**与**用户浏览网页时的地址**进行映射
- 通过vue-router可以实现嵌套路由，在一个主路由下，增加子路由，实现上文所说的减少重复代码

### element-ui

- 由饿了么开发团队所开发的一套基于vue的网页组件库
- 作为一个初学者，直接使用这样的组件库可以减少很多开发时间

### axios

- 一种基于promise(不懂)的HTTP库，用于客户端(即浏览器)向服务器发送请求，并得到服务器响应后对页面进行处理

### Springboot

- 一个后端的开发框架，将服务器处理请求的逻辑封装
- 只需要在该框架中定义控制器，将客户端发出的请求中的地址(即url)写在控制器的映射中，就可以找到相对应的方法。

### MongoDB

- 一种NoSql数据库
- NoSql的意思是(Not Only Sql)
- 它是一种非关系型的数据库，存储数据的方式是文档类型的
- 例如

``` json
{
    "username": "teacher",
    "password": "teacher123",
    "address":{
        "province": "广东省",
        "city": "珠海市"
    }
}
```

- 可以看到，这种类型的数据库不像关系型数据库只有固定的变量
- NoSQL的变量是可以嵌套的
- 相对应的

    |        SQL         |      NoSQL       |
    | :----------------: | :--------------: |
    |   数据表(Table)    | 集合(Collection) |
    | 记录(表中的某一行) |  文档(Document)  |
    | 字段(表中的某一列) |    域(Field)     |
- 相比关系型数据库，NoSQL这类数据库存储数据更加的灵活
  - 关系型数据库的结构是定死的
  - 但是非关系型数据库没有那么多的规定，NoSQL中的每一个记录都可以不一样
  - 例如

  ```json
  {
    "name": "Foo"
  },
  {
    "name": "Bar",
    "age": 15
  }
  ```

  - 可以看到两个记录有着不一样的数据格式，这样便增加了更多的灵活性。

## 使用这套技术栈的原因

1. 这学期软工大作业的前端用的是bootstrap+jquery，可能是自己弱，感觉十分的麻烦，所以打算学习一套比较新的前端框架
2. Springboot作为后端框架比较好用，而且这个学期一直在用
3. 一直学关系型数据库感觉比较脱离实际，所以想要学一下非关系型数据库，于是就从MongoDB入手了

## 开发工具

- VSCode
  - VSCode作为一个编辑器，有着丰富的插件，内置终端(也就是控制台)，用于开发前端非常的方便
- IntelliJ IDEA
  - 一个JAVA的IDE

## 开发流程

### 模块设计

- 本项目的排课系统的主要模块主要分为四个
  - 课程大纲
  - 教师安排
  - 教室管理
  - 排课管理

- 每个模块对应一个数据表，也就是文档
  - course文档
  - teacher文档
  - classroom文档
  - scheduling文档
- 其中在初期开发中为了测试前后端接口以及数据库接口，增加了一个登录的小模块并且设置了一个user文档，但这个模块主要是为了测试接口，所以不是很重要。

### 体系结构设计

- 有了模块之后开始搭建项目的体系结构
- 整个项目用的是分层的架构
  - 分层架构优点：
    - 在于只需要确定层与层之间的接口
    - 各个层之间的代码互不干扰
    - 负责某一层的程序员只需要写好自己那一层的代码就可以自行开发
    - 如果出现其它层代码写的过慢的情况，由于接口和传输的数据格式都是定死的，只需要自己写假代码就可以确认自己的代码是否有bug，也就是Mocker
- 客户端发出请求由最上层开始调用至最底层
- 服务器响应请求由最底层返回给最上层
- 前端
  - vue框架下的**展示层**界面
  - axios库发送请求给后端控制器层(Controller)
  - axios发送请求时所带的请求体称为VO(View Object)
    - VO即为展示层的对象
- 后端
  - **控制器层**(Controller)
  - **业务逻辑层**(BusinessLogic)
    - 业务逻辑层接口(Service)
    - 业务逻辑的具体实现(ServiceImpl)
  - **数据层**(Data)
  - 业务逻辑层和数据层之间传输的数据为PO(Persistent Object)
    - PO称为持久化对象，存储于数据层中，对应的就是数据库中的表格
- 体系结构图如图所示

![体系结构](https://github.com/AzureXH/CourseSchedulingDemo/blob/master/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?raw=true)

### 功能设计

- 整个项目的体系结构搭建好后，就可以开始设计具体功能了。
- 由于分好了四个模块，我们只需要在各自的模块中设计功能。
- 为了节省时间这里的功能设计我只写了每个模块的业务逻辑层的Service接口

#### Course模块

|   功能   |                 函数名称                 |                 网页请求说明                 | 数据库相关说明                       |
| :------: | :--------------------------------------: | :------------------------------------------: | ------------------------------------ |
| 增加课程 |  Boolean addCourse(CourseVO courseVO);   |             网页请求添加新的课程             | 在course集合中添加一个新的Course文档 |
| 删除课程 | Boolean deleteCourse(CourseVO courseVO); |             网页请求删除某个课程             | 将course集合中对应的Course文档删除   |
| 修改课程 | Boolean updateCourse(CourseVO courseVO); |             网页请求修改某个课程             | 将course集合中对应的Course文档修改   |
| 获取课程 |      List<CourseVO> getAllCourse();      | 网页请求获取数据库中的所有课程，用于填充表格 | 返回course集合中全部的Course文档     |

#### Classroom模块

|   功能   |                     函数名称                      |                 网页请求说明                 | 数据库相关说明                             |
| :------: | :-----------------------------------------------: | :------------------------------------------: | ------------------------------------------ |
| 增加教室 |  Boolean addClassroom(ClassroomVO classroomVO);   |             网页请求添加新的教室             | 在classroom集合中添加一个新的Classroom文档 |
| 删除教室 | Boolean deleteClassroom(ClassroomVO classroomVO); |             网页请求删除某个教室             | 将classroom集合中对应的Classroom文档删除   |
| 修改教室 | Boolean updateClassroom(ClassroomVO classroomVO); |             网页请求修改某个教室             | 将classroom集合中对应的Classroom文档修改   |
| 获取教室 |       List<ClassroomVO> getAllClassroom();        | 网页请求获取数据库中的所有教室，用于填充表格 | 返回classroom集合中全部的Classroom文档     |

#### Teacher模块

|   功能   |                  函数名称                   |                 网页请求说明                 | 数据库相关说明                         |
| :------: | :-----------------------------------------: | :------------------------------------------: | -------------------------------------- |
| 增加教师 |  Boolean addTeacher(TeacherVO teacherVO);   |             网页请求添加新的教师             | 在teacher集合中添加一个新的Teacher文档 |
| 删除教师 | Boolean deleteTeacher(TeacherVO teacherVO); |             网页请求删除某个教师             | 将teacher集合中对应的Teacher文档删除   |
| 修改教师 | Boolean updateTeacher(TeacherVO teacherVO); |             网页请求修改某个教师             | 将teacher集合中对应的Teacher文档修改   |
| 获取教师 |      List<TeacherVO> getAllTeacher();       | 网页请求获取数据库中的所有教师，用于填充表格 | 返回teacher集合中全部的Teacher文档     |

#### Scheduling模块(核心功能、没有实现)

|   功能   |                       函数名称                       |     网页请求说明     | 数据库相关说明                            |
| :------: | :--------------------------------------------------: | :------------------: | ----------------------------------------- |
| 手动排课 |      Boolean addOne(SchedulingVO schedulingVO);      | 网页请求添加新的教师 | 在teacher集合中添加一个新的Scheduling文档 |
| 自动排课 | Boolean deleteScheduling(SchedulingVO schedulingVO); | 网页请求删除某个教师 | 将teacher集合中对应的Scheduling文档删除   |

## 核心算法设计

- 这个部分是作业内容
- 因为代码我是真的写不下去了，所以我只完成了前三个模块的没什么技术含量的CRUD(create、read、update、delete)
- 虽说这个是核心算法，但是我并不打算把这个当做是这个报告的重点
  - 所以以下的内容会没有什么技术含量，并且会比较水

### 假设

- 课程没有单双周
- 不存在多个学院一起上同一门课的情况
- 上课时间为
  - 每天的8:00-12:00 分为4个课时 1 2 3 4
  - 每天的14:00-18:00 分为4个课时 5 6 7 8
  - 每天的18:30-21:30 分为3个课时 9 10 11
  
- 学分只有 2 3 4 5 6，每周学时等于学分
  - 学分为3的课程按照一周一次课，一次课为三节连堂的方式进行上课
    - 比如在周一上午的2 3 4节课上课
  - 学分为5的课程按照一周上两次课，一次课为两节连堂的，另一次课为三节连堂的方式进行上课
  - 学分为偶数的课程按照一周上 学分/2 (1、2、3) 次课，每次课为两节连堂的方式进行上课
- 三节连堂的课程只能在以下时间段上课
  - 上午的2 3 4节课
  - 下午的5 6 7节课
  - 晚上的9 10 11节课
- 课程可以由授课院系授课，而不是由开课院系授课
  - 比如每个院都会开大学英语，但是授课院系是外国语学院

### 数据说明

#### 时间的表示

- 这个算法设计比较核心的地方就是时间要怎么表示，因为用1、2、3、4去表示课时很容易出问题
- 我只看了提供的第一个算法，所以大致思想是跟第一个算法一样的
- 我们用一个字符串表示时间，这个字符串分为三个部分
  - 星期几
  - 上午下午晚上
  - 一个三位或四位的二进制字符串表示前两个部分的时间段下的空闲时间，1表示空闲，0表示被占用
- 比如教室中的一个属性teaching = “星期一上午0011”
  - 表示的是星期一上午1 2 节课这个教室被占用了
- 后面的二进制字符串可能是三位的
  - 因为晚上只有三个课时是授课的
  - 比如老师中的一个属性teaching = “星期三晚上000”
    - 表示的是星期三晚上9 10 11节课这个老师在上课

### 外部输入参数

- 外部输入的参数用于控制算法的迭代
- 所需要的参数有
  - 上午剩余的空闲教室百分比
  - 下午剩余的空闲教室百分比
  - 晚上剩余的空闲教室百分比

### 数据库设计

- 因为采用的是MongoDB，所以数据库会有Array数组

#### Course文档

|        域         |   类型   | 说明                                                         |
| :---------------: | :------: | :----------------------------------------------------------- |
|        _id        | ObjectId | MongoDB自动生成的哈希值                                      |
|    department     |  String  | 开这门课程的院系                                             |
| teacherDepartment |  String  | 授课院系                                                     |
|       name        |  String  | 课程名                                                       |
|       term        |  Int32   | 开课的学期(其实这个值是没有用的，因为排课只排当前学期的课程) |
|      credits      |  Int32   | 这门课的学分，也就是每周课时                                 |
|   need_credits    |  Int32   | 这门课为排课的每周课时                                       |
|      number       |  Int32   | 课程上课人数                                                        |
|   number_level    |  Int32   | 课程上课人数的等级(根据number的值自动计算，0-30为1，每30人+1)       |
|     teaching      |  Array   | 这门课的上课时间，MongoDB可以用数组存储数据，并且可以存放String类型 |

#### Classroom文档

|     域     |   类型   | 说明                                                                |
| :--------: | :------: | :------------------------------------------------------------------ |
|    _id     | ObjectId | MongoDB自动生成的哈希值                                             |
|  building  |  String  | 教室所属的教学楼                                                    |
|    room    |  String  | 教室名                                                              |
| available  |  Int32   | 可容纳人数                                                          |  |
| size_level |  Int32   | 教室大小等级(根据available的值自动计算，0-30为1，每30人+1)          |  |
|  teaching  |  Array   | 教室的被占用时间，MongoDB可以用数组存储数据，并且可以存放String类型 |

#### Teacher文档

|     域     |   类型   | 说明                                                              |
| :--------: | :------: | :---------------------------------------------------------------- |
|    _id     | ObjectId | MongoDB自动生成的哈希值                                           |
| department |  String  | 教师所属的院系                                                    |
|    name    |  String  | 教师名                                                            |
|   title    |  String  | 教师职称(教授、副教授、讲师 为3、2、1级)                          |  |
|  teaching  |  Array   | 教师的上课时间，MongoDB可以用数组存储数据，并且可以存放String类型 |

#### Scheduling文档

|     域      |   类型   | 说明                                                              |
| :---------: | :------: | :---------------------------------------------------------------- |
|     _id     | ObjectId | MongoDB自动生成的哈希值                                           |
|  courseId   | ObjectId | 课程Id                                                            |
| classroomId | ObjectId | 教室Id                                                            |
|  teacherId  | ObjectId | 教师Id                                                            |  |
|  teaching   |  Array   | 课程的上课时间，MongoDB可以用数组存储数据，并且可以存放String类型 |

### 算法实现

- 因为没有实现，所以只有个大致的叙述，其实整个算法就是贪心，效果好不好我也不知道，没有做出来的事情光用数学去说出来的事，我没这个能力做，因为我只是个不学无术、好吃懒做的差等生。

1. 首先从数据库中获取所有的数据得到CourseList、TeacherList、ClassroomList三个列表，并且为了简化问题假设自动排课前是对象的teaching属性均为空，不为空会很麻烦
   1. 将CourseList依照课程人数number从大到小排列(MongoDB就可以做到，我也没查这个排序的时间复杂的是几)
   2. 同样将ClassroomList依照容纳量available从大到小排序
   3. 将TeacherList依照title从小到大排序
2. 设立一个上课时间的拼接字符串，并用三个非临时变量记录当前遍历的节点
  
```java
String day[] = {"周一","周三","周二","周四","周五",};//优先周一周三上课，其次周二周四，为了上课时间有间隔，周五大家都想回家
String period[] = {"上午","下午","晚上"};
String time[] = {"0011","1100","1000","0001","001","000"}   //分别表示12节课或56节课,34节课或78节课,234节课,567节课,910节课,91011节课
```

3. 获取三个时间段的空闲教室百分比(是从网页的输入获取的，其实这个是第一步，但是不重要)

  ```java
  double morning;
  double afternoon;
  double night;
  ```

5. forEach遍历CourseList,用一个元素course作为当前遍历的节点
6. for遍历ClassroomList,用一个非临时变量记录当前遍历到的classroom，**跳出条件为当前时间段的空闲教室百分比morning或afternoon或night乘以教师数量**
   1. 检测course的number_size是否等于ClassroomList[i].size_level并且当前教室是否可以被占用[(注解)](#检测当前教室是否可以被占用)
   2. 大于说明教室太小则将i--继续遍历
      1. 超出范围
   3. 小于说明教室太大则将i++继续遍历
   4. 教室被占用则i++往下遍历
   5. 等于则将course的need_credits属性减去2或3(该课程的need_credits为偶数则减2，为奇数则减3)
      1. 分配一个授课院系的老师进行授课，将上课时间的拼接字符串更新到当前的course、classroom、teacher对象
7. 就这样一直遍历下去，能不能成功我不知道，但是代码都会有bug，所以我选择点调试

#### 检测当前教室是否可以被占用

- 例子：检测某教室"周一上午一二节课"是否可以被占用
- 实现：

1. 输入参数"周一上午0011"
2. 遍历该教室的teaching数组，先对比字符串的前四位
3. 前四位对比成功
4. 对后四位进行位或运算
   1. 比如teaching数组中含有"周一上午1000",
   2. 将0011和1000每一位做或运算
   3. 第一位，后者有个1，得1
   4. 第二位，没有人有1，得0
   5. 第三位，前者有个1，得1
   6. 第四位，前者有个1，得1
   7. 得到结果1011
   8. 结果含有0，说明请求的时间和该教室的上课时间冲突

完

